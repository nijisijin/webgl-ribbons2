{"id":"src/shaders/fragment3.glsl","dependencies":[{"name":"/Users/nijis/Desktop/Threejs/parcel/webgl-ribbons2/package.json","includedInParent":true,"mtime":1651865989006}],"generated":{"js":"module.exports = \"#define GLSLIFY 1\\nuniform float time;\\nvarying vec2 vUv;\\nvarying vec3 vPosition;\\n\\n//Noise\\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\\n\\nfloat noise(vec3 p){\\n    vec3 a = floor(p);\\n    vec3 d = p - a;\\n    d = d * d * (3.0 - 2.0 * d);\\n\\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\\n    vec4 k1 = perm(b.xyxy);\\n    vec4 k2 = perm(k1.xyxy + b.zzww);\\n\\n    vec4 c = k2 + a.zzzz;\\n    vec4 k3 = perm(c);\\n    vec4 k4 = perm(c + 1.0);\\n\\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\\n\\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\\n\\n    return o4.y * d.y + o4.x * (1.0 - d.y);\\n}\\n\\nfloat lines(vec2 uv, float offset){\\n    return smoothstep(\\n        0., 0.5 + offset * 0.5,\\n        abs(0.5 * (sin(uv.x*20.) + offset*2.))\\n    );\\n}\\n\\nmat2 rotate2D(float angle){\\n    return mat2(\\n        cos(angle),-sin(angle),\\n        sin(angle),cos(angle)\\n    );\\n}\\n\\nvoid main(){\\n    float n = noise(vPosition + time);\\n\\n    vec3 baseFirst = vec3(120./255., 158./255., 113./255.);\\n    vec3 accent = vec3(0.1098, 0.1843, 0.298);\\n    vec3 baseSecond = vec3(224./255., 148./255., 66./255.);\\n\\n    \\n    vec2 baseUV = rotate2D(n) * vPosition.xy*0.8;\\n    float basePattern = lines(baseUV, 0.7);\\n    float secondPattern = lines(baseUV, 0.05);\\n\\n    vec3 baseColor = mix(baseSecond,baseFirst,basePattern);\\n    vec3 secondColor = mix(baseColor,accent,secondPattern);\\n\\n    gl_FragColor = vec4(vec3(secondColor),1.);\\n}\";"},"sourceMaps":{"js":{"mappings":[{"generated":{"line":1,"column":0},"source":"src/shaders/fragment3.glsl","original":{"line":1,"column":0},"name":"module"},{"generated":{"line":1,"column":6},"source":"src/shaders/fragment3.glsl","original":{"line":1,"column":6}},{"generated":{"line":1,"column":7},"source":"src/shaders/fragment3.glsl","original":{"line":1,"column":7},"name":"exports"},{"generated":{"line":1,"column":14},"source":"src/shaders/fragment3.glsl","original":{"line":1,"column":0}},{"generated":{"line":1,"column":17},"source":"src/shaders/fragment3.glsl","original":{"line":1,"column":15}},{"generated":{"line":1,"column":1678},"source":"src/shaders/fragment3.glsl","original":{"line":1,"column":0}}],"sources":{"src/shaders/fragment3.glsl":"module.exports=\"#define GLSLIFY 1\\nuniform float time;\\nvarying vec2 vUv;\\nvarying vec3 vPosition;\\n\\n//Noise\\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\\n\\nfloat noise(vec3 p){\\n    vec3 a = floor(p);\\n    vec3 d = p - a;\\n    d = d * d * (3.0 - 2.0 * d);\\n\\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\\n    vec4 k1 = perm(b.xyxy);\\n    vec4 k2 = perm(k1.xyxy + b.zzww);\\n\\n    vec4 c = k2 + a.zzzz;\\n    vec4 k3 = perm(c);\\n    vec4 k4 = perm(c + 1.0);\\n\\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\\n\\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\\n\\n    return o4.y * d.y + o4.x * (1.0 - d.y);\\n}\\n\\nfloat lines(vec2 uv, float offset){\\n    return smoothstep(\\n        0., 0.5 + offset * 0.5,\\n        abs(0.5 * (sin(uv.x*20.) + offset*2.))\\n    );\\n}\\n\\nmat2 rotate2D(float angle){\\n    return mat2(\\n        cos(angle),-sin(angle),\\n        sin(angle),cos(angle)\\n    );\\n}\\n\\nvoid main(){\\n    float n = noise(vPosition + time);\\n\\n    vec3 baseFirst = vec3(120./255., 158./255., 113./255.);\\n    vec3 accent = vec3(0.1098, 0.1843, 0.298);\\n    vec3 baseSecond = vec3(224./255., 148./255., 66./255.);\\n\\n    \\n    vec2 baseUV = rotate2D(n) * vPosition.xy*0.8;\\n    float basePattern = lines(baseUV, 0.7);\\n    float secondPattern = lines(baseUV, 0.05);\\n\\n    vec3 baseColor = mix(baseSecond,baseFirst,basePattern);\\n    vec3 secondColor = mix(baseColor,accent,secondPattern);\\n\\n    gl_FragColor = vec4(vec3(secondColor),1.);\\n}\";"},"lineCount":null}},"error":null,"hash":"ff3d07932da914414c4299421ef2d570","cacheData":{"env":{}}}